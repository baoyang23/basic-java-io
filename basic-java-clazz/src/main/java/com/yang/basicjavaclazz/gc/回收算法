标记清除算法:  Mark-Sweep是最基础的一种垃圾回收算法,它分为二部分,先把内存区域中的这些对象进行标记,那些属于可回收的标记出来,
               然后将这些垃圾拿出来清理掉. 清理掉的垃圾就变成未使用的内存区域,等待再次被使用.
               问题 : 内存碎片. 你清除的垃圾使用的内存可能是1M,2M等,所以我们回收完了,内存就被切成了很多段.
                      我们开辟内存空间时,需要的是连续内存区域,这时候我们需要一个2M的内存,然后二个1M(经过垃圾回收后的)的是没法
                      使用的. 这就导致了,其实我们还是有内存的,但是却用不了的问题.

复制算法:  复制算法是在标记清除上演化而来,处理了标记算法的内存碎化问题.它将可用内存按容量划分为大小相等的两块,每次只是用其中的
           一块. 当这一块内存用完了,就将还存活的对象复制到另外一快上面,然后再把已使用的过的内存空间一次清理掉。
           保证内存的连续可用,内存分配时也就不用考虑内存碎化等复杂情况了.
           问题 : 如果是1G的内存,那么使用的内存只有0.5G. 代价太高了

标记整理算法:  Mark-Compact 标记过程与标记清除算法一样,但是后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端,
               在清理掉端边界以外的内存区域. 标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，
               也规避了复制算法只能利用一半内存区域的弊端。看起来很美好.但是它对内存变动更频繁,需要整理所有存活的引用地址,
               在效率上比复制算法要差很多.

分代收集算法: Generational Collection. 融合了上面三种基础的算法思,而针对不同的情况所采用的不同算法的一套组合拳.对象存活周期的不同
              将内存划分为几块。一般是把Java堆分为新生代和老年代,这样就可以根据各个年代的特点采用最合适的算法。在新生代中,每次垃圾
              收集时都发现有大批对象死去,只有少量存活,那就选用复制算法,只需要付出少量存活对象的复制成本就可以完成收集.
              而老年代中因为对象存活率比较高,没有额外空间对它进行分配担保,就必须使用标记-清理或者标记-整理算法回收。

内存模型与回收策略:  Java Heap(Java堆),是JVM所管理的内存中最大的一块,堆又是垃圾收集器的主要区域.
                     Java Heap主要分为2个区域: 年轻代和老年代. 其中年轻代又分为Eden区和Survivor区,其中Survivor区又分为
                     From和To二个区。
                     Eden区 :  对象会在新生代Eden区中进行分配，当Eden区没有足够空间进行分配时，虚拟机会发起一次Minor GC.
                                Minor GC相比于Major GC更频繁,回收速度也更快.通过Minor GC之后,Eden会被清空,Eden区中绝大部分
                                对象会被回收,而那些无需回收的存活对象,将会进到Survivor的From区(如果From区不够,就直接进入Old区).
                     Survivor区 : Survivor区相当于是Eden区和Old区的一个缓冲，类似于我们交通灯中的黄灯。Survivor又分为2个区，
                                   一个是From区，一个是To区。每次执行Minor GC，会将Eden区和From存活的对象放到Survivor的To区
                                   （如果To区不够，则直接进入Old区）。
                                   如果Eden区每进行次MinorGC,存活的对象就很快被送到老年代的话,老年代很快就会被填满。而很多对象,
                                   虽然一次MinorGCm没有消灭,但其实也是蹦跶不了多久的,或者第二次,第三次就需要被清除。
                                   Survivor的存在意义就是减少被送到老年代的对象，进而减少Major GC的发生。
                                   Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
                     Survivor区 ： 设置两个Survivor区最大的好处就是解决内存碎片化。当Eden区被清空了,存活的对象放到了Survivor区,
                                   而之前Survivor区中的对象,可能有一些是需要被清除的。问题来了,这个时候怎么清除呢?在这种场景下,
                                   只能使用标记清除,而我们知道标记清除最大的问题就是内存碎化,在新生代这种经常会消亡的区域,采用
                                   标记清除必然会让内存产生严重的碎片化.因为Survivor有2各区域,所以每次MinorGC,会将之前的Eden区和
                                   From区中的内活对象复制到To区域. 第二个MinorGC是,From与To职责兑换,这时候Eden区和To区中的存活
                                   对象再复制到From区域,以此反复.
                     Old区: 来年代占据着2/3的对内空间,只有再MajorGC的时候才会进行清理,每次GC都会触发"Stop-The-Word". 内存越大,
                            STW时间也就越长.所以内存也不仅仅是越大越好. 由于复制算法在对象存活率较高的老年代会进行很多次的复制操作,
                            效率很低,所以老年代这里采用的标记-整理算法.
                            除了无法安置的对象会直接进入到老年代, 这种也会.
                            大对象 :  大对象需要大量的连续内存的对象,这部分对象不管是不是"朝生夕死",都会直接进入到来年代.这样做的
                                    目的是为了避免在Eden区以及二个Survivor区之间发生大量的复制内存。
                            长期存活对象 :  虚拟机给每个对象定义了一个对象年龄计算器。正常情况下对象会不断的在Survivor的From区和To区
                                        之间移动,对象在Survivor区中没有经历一次MinorGC,年龄就会增加1,当年龄增加到15的时候,这时候j就会
                                        被转移到老年代. 当然，这里的15，JVM也支持进行特殊设置。
                            动态对象年龄 : 虚拟机并不重视要求对象年龄必须达到15,才会放入老年代,如果Survivor空间中相同的年龄代所有对象
                                        大小总和大于Survivor空间的一半,年龄大于等于该年龄的对象就可以直接进去老年代,无需等"成年"。




